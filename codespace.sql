-- MySQL dump 10.13  Distrib 8.3.0, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: codespace
-- ------------------------------------------------------
-- Server version	8.3.0

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `algorithm`
--

DROP TABLE IF EXISTS `algorithm`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `algorithm` (
  `algo_id` int unsigned NOT NULL AUTO_INCREMENT COMMENT '算法库id',
  `title` varchar(20) NOT NULL COMMENT '算法名',
  `content` mediumtext NOT NULL COMMENT '算法文件内容',
  `author` int unsigned NOT NULL COMMENT '作者用户id',
  `desc` varchar(500) NOT NULL COMMENT '算法简介',
  `line` int unsigned NOT NULL COMMENT '算法文件行数',
  `language` varchar(10) NOT NULL DEFAULT 'txt' COMMENT '算法文件使用的编程语言，统一为文件后缀名',
  PRIMARY KEY (`algo_id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb3 COMMENT='算法库表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `algorithm`
--

LOCK TABLES `algorithm` WRITE;
/*!40000 ALTER TABLE `algorithm` DISABLE KEYS */;
INSERT INTO `algorithm` VALUES (1,'quick-sort','public void quickSort(int[] arr, int low, int hight){ \n...',2,'a quick-sort test',33,'java'),(9,'shortest-path','package software.engineer;\r\n\r\nimport java.awt.*;\r\nimport java.io.*;\r\nimport java.util.*;\r\nimport java.util.List;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.LogManager;\r\nimport java.util.logging.Logger;\r\n\r\nimport guru.nidi.graphviz.attribute.Color;\r\nimport guru.nidi.graphviz.engine.Format;\r\nimport guru.nidi.graphviz.engine.Graphviz;\r\nimport guru.nidi.graphviz.model.Factory;\r\nimport guru.nidi.graphviz.model.Link;\r\nimport guru.nidi.graphviz.model.LinkSource;\r\nimport guru.nidi.graphviz.model.Node;\r\nimport org.apache.batik.swing.JSVGCanvas;\r\nimport org.jnativehook.GlobalScreen;\r\nimport org.jnativehook.NativeHookException;\r\nimport org.jnativehook.keyboard.NativeKeyEvent;\r\nimport org.jnativehook.keyboard.NativeKeyListener;\r\n\r\nimport javax.swing.*;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Objects;\r\nimport java.util.stream.Collectors;\r\n\r\nimport static guru.nidi.graphviz.model.Factory.graph;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.Map;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\n\r\n/**\r\n * 通过命令行参数读取文件内容，并实现预处理\r\n */\r\nclass InputFile\r\n{\r\n    private static final String FILE_PATH = \"article.txt\";\r\n    private String file_path = null;\r\n    private final String[] words;\r\n\r\n    public InputFile(String[] args) throws IOException {\r\n        read_args(args);\r\n        this.words = read();\r\n    }\r\n\r\n    /**\r\n     * 读取命令行参数中的指定文件（-f, --file）\r\n     * @param args 参数列表\r\n     */\r\n    public void read_args(String[] args){\r\n        for (int i = 0; i < args.length; i++) {\r\n            if ((\"-f\".equals(args[i]) || \"--file\".equals(args[i])) && i + 1 < args.length) {\r\n                this.file_path = args[i + 1];\r\n                break;\r\n            }\r\n        }\r\n        if (this.file_path == null) this.file_path = FILE_PATH;\r\n    }\r\n\r\n    /**\r\n     * 输入文件，预处理文件内容，返回单词列表\r\n     * @return 单词列表\r\n     */\r\n    private String[] read() throws IOException {\r\n        StringBuilder content = new StringBuilder();\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(this.file_path))) {\r\n            String line;\r\n            while ((line = reader.readLine()) != null) {\r\n                content.append(line).append(\" \");\r\n            }\r\n        }\r\n        String filter_non_alphabet = content.toString().replaceAll(\"[^A-Za-z]\", \" \"); // 将非字母字符替换为空格\r\n        return filter_non_alphabet.toLowerCase().split(\"\\\\s+\");\r\n    }\r\n\r\n    public String[] getWords() {\r\n        return this.words;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * 图结构的接口\r\n * 后期可能需要用不同的数据结构实现程序：\r\n * -[x] 邻接矩阵的图结构（稠密图）\r\n * -[ ] 邻接表的图结构（稀疏图）\r\n */\r\ninterface Graph {\r\n    int size(); // 顶点数\r\n\r\n    /* 顶点 */\r\n    void addVertex(String vertex);\r\n    List<String> getVertexes(); // 顶点列表V\r\n    int getVertex(String vertex); // vertex -> index\r\n    String getVertex(int index); // index -> vertex\r\n    List<String> getNeighbors(String v); // 邻居节点\r\n\r\n    /* 边 */\r\n    void addEdge(String a, String b) throws Exception; // 添加边（边权重+1）\r\n    void addEdge(String a, String b, int value) throws Exception; // 设置边权重为 value\r\n    int getEdge(String a, String b);\r\n    List<Edge> getEdges(); // 边列表E\r\n\r\n\r\n    /* 显示 */\r\n    void print();\r\n\r\n    /* 图算法 */\r\n    List<List<Object>> Dijkstra(String v); // [路径, 路径长度]\r\n}\r\n\r\n\r\nrecord Edge(String from, String to, int value) {\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"(\" + from + \", \" + to + \") = \" + value;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n        Edge edge = (Edge) o;\r\n        return value == edge.value && Objects.equals(from, edge.from) && Objects.equals(to, edge.to);\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * 邻接矩阵数据结构的图实现\r\n */\r\nclass AdjMatrixGraph implements Graph{\r\n    private final List<String> vertexes;\r\n    private int[][] edges;\r\n    private int size;\r\n\r\n    public AdjMatrixGraph(String[] vertexes, int[][] edges) {\r\n        this.vertexes = new ArrayList<>(Arrays.asList(vertexes));\r\n        this.edges = edges;\r\n    }\r\n    public AdjMatrixGraph(String[] vertexes) {\r\n        this.vertexes = new ArrayList<>(Arrays.asList(vertexes));\r\n        this.size = this.vertexes.size();\r\n        this.edges = new int[this.size][this.size];\r\n    }\r\n    public AdjMatrixGraph(){\r\n        this.vertexes = new ArrayList<>();\r\n        this.size = 0;\r\n        this.edges = new int[0][];\r\n    }\r\n    @Override\r\n    public int size() {\r\n        return this.size;\r\n    }\r\n\r\n    @Override\r\n    public void addVertex(String vertex) {\r\n        this.vertexes.add(vertex);\r\n        int[][] newEdges = new int[this.size+1][this.size+1];\r\n        for (int i=0; i<this.size; i++){\r\n            System.arraycopy(this.edges[i], 0, newEdges[i], 0, this.size);\r\n        }\r\n        this.edges = newEdges;\r\n        this.size++;\r\n    }\r\n\r\n    @Override\r\n    public List<String> getVertexes() {\r\n        return vertexes;\r\n    }\r\n\r\n    @Override\r\n    public List<String> getNeighbors(String v) {\r\n        List<String> results = new ArrayList<>();\r\n        if (vertexes.contains(v)){\r\n            int index = vertexes.indexOf(v);\r\n            for (int i=0; i<this.size; i++){\r\n                if (this.edges[index][i] > 0) results.add(vertexes.get(i));\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n\r\n    @Override\r\n    public int getVertex(String vertex) {\r\n        return vertexes.indexOf(vertex);\r\n    }\r\n\r\n    @Override\r\n    public String getVertex(int index) {\r\n        if (index < this.size && index >=0)\r\n            return vertexes.get(index);\r\n        else {\r\n            throw new IndexOutOfBoundsException(index);\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public void addEdge(String a, String b, int value) throws Exception {\r\n        if (vertexes.contains(a) && vertexes.contains(b)){\r\n            int index_a = vertexes.indexOf(a);\r\n            int index_b = vertexes.indexOf(b);\r\n            this.edges[index_a][index_b] = value;\r\n        }\r\n        else {\r\n            throw new Exception(\"Vertex is not exist\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void addEdge(String a, String b) throws Exception {\r\n        if (vertexes.contains(a) && vertexes.contains(b)){\r\n            int index_a = vertexes.indexOf(a);\r\n            int index_b = vertexes.indexOf(b);\r\n            this.edges[index_a][index_b]++;\r\n        }\r\n        else {\r\n            throw new Exception(\"Vertex is not exist\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public List<Edge> getEdges() {\r\n        List<Edge> results = new ArrayList<>();\r\n        for (int i=0; i<this.size; i++){\r\n            for (int j=0; j<this.size; j++){\r\n                if (edges[i][j] > 0)\r\n                    results.add(new Edge(vertexes.get(i), vertexes.get(j), edges[i][j]));\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n\r\n    @Override\r\n    public int getEdge(String a, String b) {\r\n        if (vertexes.contains(a) && vertexes.contains(b)) {\r\n            int index_a = vertexes.indexOf(a);\r\n            int index_b = vertexes.indexOf(b);\r\n            return edges[index_a][index_b];\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void print() {\r\n        System.out.println(\"Adjacency Matrix:\");\r\n        System.out.println(this.vertexes.toString());\r\n        for (int[] row : this.edges) {\r\n            System.out.println(Arrays.toString(row));\r\n        }\r\n    }\r\n\r\n    private int distance(int[][] dis, int i, int j){\r\n        if (dis[i][j] > 0) return dis[i][j];\r\n        else return 10000000;\r\n    }\r\n\r\n    @Override\r\n    public List<List<Object>> Dijkstra(String v) {\r\n        if (!this.vertexes.contains(v)) return null;\r\n        int start = vertexes.indexOf(v);\r\n        int[] visit = new int[this.size];\r\n        int[] bestmin = new int[this.size];\r\n        String[] path = new String[this.size];\r\n        int max = 10000000;\r\n        int[][] dis = new int[this.size][this.size];\r\n        for(int i=0; i<this.size; i++) dis[i]=Arrays.copyOf(edges[i], this.size);\r\n        visit[start] = 1;\r\n        bestmin[start] = 0;\r\n\r\n        //大循环（搞定这里就算搞定该算法了，后面的输出什么的可以不看）\r\n        for(int l = 0; l < this.size; l++) {\r\n            int Dtemp = max;\r\n            int k = -1;\r\n\r\n            //步骤① 找出与源点距离最短的那个点，即遍历distance[1][1]，distance[1][2],.....distance[1][N]中的最小值\r\n            for(int i = 0; i < this.size; i++) {\r\n                if(visit[i] == 0 && distance(dis, start, i) < Dtemp) {\r\n                    Dtemp = distance(dis, start, i);\r\n                    k = i;\r\n                }\r\n            }\r\n            if (k == -1) continue;\r\n            visit[k] = 1;\r\n            bestmin[k] = Dtemp;\r\n\r\n            //步骤② 松弛操作\r\n            for(int i = 0; i < this.size; i++) {\r\n                if(visit[i] == 0 && (distance(dis, start, k) + distance(dis, k, i)) < distance(dis, start, i)) {\r\n                    dis[start][i] = distance(dis, start, k) + distance(dis, k, i);\r\n                    path[i] = (path[k]==null?(v+\"-->\"+ vertexes.get(k)):path[k]) + \"-->\" + vertexes.get(i);\r\n                }\r\n                if (path[i] == null && (bestmin[i] > 0 || i==start)) path[i] = v+\"-->\"+ vertexes.get(i);\r\n            }\r\n        }\r\n\r\n        //输出路径\r\n        List<List<Object>> results = new ArrayList<>();\r\n        for(int i=0; i<this.size; i++) {\r\n            List<Object> t = new ArrayList<>();\r\n            t.add(path[i]!=null?path[i]:v+\" -x \"+ vertexes.get(i)+\" 不可达\");\r\n            t.add(path[i]!=null?bestmin[i]:-1);\r\n            results.add(t);\r\n        }\r\n        return results;\r\n    }\r\n}\r\n\r\n\r\npublic class App\r\n{\r\n    private static Graph graph;\r\n    private static final ImageFrame imageFrame = new ImageFrame();\r\n\r\n    static volatile boolean isRunning=true;\r\n\r\n    /**\r\n     * 主程序入口，接收用户输入文件，生成图，并允许用户选择后续各项功能\r\n     * @param args -f 或者 --file 指定输入文件路径\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        // 关闭日志显示\r\n        LogManager.getLogManager().reset();\r\n        Logger logger = Logger.getLogger(GlobalScreen.class.getPackage().getName());\r\n        logger.setLevel(Level.OFF);\r\n\r\n        InputFile inputFile = new InputFile(args);\r\n        String[] words = inputFile.getWords();\r\n        graph = buildGraph(words);\r\n        Scanner scanner = new Scanner(System.in);\r\n        String input;\r\n        boolean flag = true;\r\n        while (flag) {\r\n            System.out.println(\"====================\");\r\n            System.out.println(\"请选择后续功能：\");\r\n            System.out.println(\"1. 展示有向图\");\r\n            System.out.println(\"2. 查询桥接词\");\r\n            System.out.println(\"3. 根据桥接词生成新文本\");\r\n            System.out.println(\"4. 计算两个单词之间的最短路径\");\r\n            System.out.println(\"5. 随机游走\");\r\n            System.out.println(\"0. 退出\");\r\n\r\n            int choice;\r\n            while (!(scanner.hasNextInt())) {\r\n                scanner.next();\r\n                System.out.println(\"请输入一个数字：\");\r\n            }\r\n            choice=scanner.nextInt();\r\n            scanner.nextLine();\r\n            switch (choice) {\r\n                case 1 -> showDirectedGraph(graph);\r\n                case 2 -> {\r\n                    System.out.println(\"请输入两个单词(\" + graph.getVertexes().toString() + \"): \");\r\n                    input = scanner.nextLine();\r\n                    words = input.split(\"\\\\s+\");\r\n                    while (words.length < 2) {\r\n                        System.out.println(\"请输入『两个』单词\");\r\n                        input = scanner.nextLine();\r\n                        words = input.split(\"\\\\s+\");\r\n                    }\r\n                    queryBridgeWords(words[0], words[1], true);\r\n                }\r\n                case 3 -> {\r\n                    System.out.println(\"请输入一个句子\");\r\n                    input = scanner.nextLine();\r\n                    System.out.println(generateNewText(input));\r\n                }\r\n                case 4 -> {\r\n                    System.out.println(\"请输入一个或者两个单词(\" + graph.getVertexes().toString() + \"): \");\r\n                    input = scanner.nextLine();\r\n                    words = input.split(\"\\\\s+\");\r\n                    while (words.length < 1) {\r\n                        System.out.println(\"请输入『一个或者两个』单词\");\r\n                        input = scanner.nextLine();\r\n                        words = input.split(\"\\\\s+\");\r\n                    }\r\n                    if (words.length == 1) System.out.println(calcShortestPath(words[0]));\r\n                    else System.out.println(calcShortestPath(words[0], words[1]));\r\n                }\r\n                case 5 -> {\r\n                    String randomwalk = randomWalk();\r\n                    PrintWriter out = new PrintWriter(\"random_walk.txt\");\r\n                    out.print(randomwalk);\r\n                    out.close();\r\n                }\r\n                case 0 -> flag = false;\r\n                default -> System.out.println(\"无效选择，请重新输入\");\r\n            }\r\n        }\r\n        //这行不能删，因为画图程序会开后台线程（或者进程，不清楚），删去这行后画图线程（进程）不结束，程序无法退出。\r\n        System.exit(0);\r\n    }\r\n\r\n    private static Graph buildGraph(String[] words) throws Exception {\r\n        Set<String> set = new HashSet<>(Arrays.asList(words));\r\n        Graph graph = new AdjMatrixGraph(set.toArray(new String[0]));\r\n        String previousWord = null;\r\n        for (String word : words) {\r\n            if (previousWord != null) {\r\n                graph.addEdge(previousWord, word);\r\n            }\r\n            previousWord = word;\r\n        }\r\n        return graph;\r\n    }\r\n\r\n    /**\r\n     * 展示生成的有向图\r\n     * ✅ 可选功能：将生成的有向图以图形文件形式保存到磁盘，可以调用外部\r\n     * 绘图库或绘图工具API自动生成有向图，但不能采用手工方式绘图\r\n     * @param g 有向图\r\n     * @param path 突出标注路径\r\n     * @param filename 保存文件名\r\n     */\r\n    private static void showDirectedGraph(Graph g, List<Edge> path, String filename) throws IOException {\r\n        imageFrame.draw(g, path, filename);\r\n    }\r\n\r\n    private static void showDirectedGraph(Graph g) throws IOException {\r\n        showDirectedGraph(g, new ArrayList<>(), \"graph.svg\");\r\n    }\r\n\r\n    /**\r\n     * 在生成有向图之后，用户输入任意两个英文单词word1、word2，程\r\n     * 序从图中查询它们的“桥接词”。\r\n     * @param word1 单词1\r\n     * @param word2 单词2\r\n     * @param message 是否显示提示信息（功能3需要显示。功能4复用函数时不显示）\r\n     * @return 桥接词列表\r\n     */\r\n    private static List<String> queryBridgeWords(String word1, String word2, boolean message){\r\n        List<String> results = new ArrayList<>();\r\n        if (graph.getVertexes().contains(word1) && graph.getVertexes().contains(word2)){\r\n            List<String> pos = graph.getNeighbors(word1);\r\n            for (String p : pos){\r\n                if (graph.getNeighbors(p).contains(word2))\r\n                    results.add(p);\r\n            }\r\n        }\r\n        else if(message){\r\n            System.out.println(\"No \\\"\" + word1 + \"\\\" or \\\"\" + word2 + \"\\\" in the graph!\");\r\n        }\r\n\r\n        // 输出提示词\r\n        if (message){\r\n            if (results.size() == 0){\r\n                System.out.println(\"No bridge words from \\\"\" + word1 + \"\\\" to \\\"\" + word2 + \"\\\"!\");\r\n            } else if (results.size() == 1) {\r\n                System.out.println(\"The bridge word from \\\"\" + word1 + \"\\\" to \\\"\" + word2 + \"\\\" is: \"+results.get(0));\r\n            } else {\r\n                StringJoiner joiner = new StringJoiner(\", \", \"The bridge words from \\\"\" + word1 + \"\\\" to \\\"\" + word2 + \"\\\" are: \", \".\");\r\n                for (int i = 0; i < results.size(); i++) {\r\n                    if (i == results.size() - 1) joiner.add(\"and \" + results.get(i));\r\n                    else joiner.add(results.get(i));\r\n                }\r\n                System.out.println(joiner);\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n\r\n    private static List<String> queryBridgeWords(String word1, String word2) {\r\n        return queryBridgeWords(word1, word2, false);\r\n    }\r\n\r\n    /**\r\n     * 用户输入一行新文本，程序根据之前输入文件生\r\n     * 成的图，计算该新文本中两两相邻的单词的\r\n     * bridge word，将bridge word插入新文本的两个\r\n     * 单词之间，输出到屏幕上展示。\r\n     * *********************\r\n     * 测试输入：Seek to explore new and exciting synergies\r\n     * 预期输出：Seek to explore strange new life and exciting synergies\r\n     * *********************\r\n     *  @param inputText 用户输入的一行新文本\r\n     * @return 新生成的字符串\r\n     */\r\n    private static String generateNewText(String inputText) {\r\n        String filter_non_alphabet = inputText.replaceAll(\"[^A-Za-z]\", \" \"); // 将非字母字符替换为空格\r\n        String[] words = filter_non_alphabet.split(\"\\\\s+\"); // 分割处理后的文本\r\n        String preword = null;\r\n        StringBuilder result = new StringBuilder();\r\n        for (String word : words){\r\n            if (preword != null){\r\n                List<String> bridges = queryBridgeWords(preword, word.toLowerCase());\r\n                if (bridges.size() == 1) result.append(bridges.get(0)).append(\" \");\r\n                else if (bridges.size() > 1) {\r\n                    Random random = new Random();\r\n                    int randomIndex = random.nextInt(bridges.size());\r\n                    result.append(bridges.get(randomIndex)).append(\" \");\r\n                }\r\n            }\r\n            result.append(word).append(\" \");\r\n            preword = word.toLowerCase();\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * 用户输入两个单词，程序计算它们之间在图中的\r\n     * 最短路径（路径上所有边权值之和最小），以某\r\n     * 种突出的方式将路径标注在原图并展示在屏幕上\r\n     * ，同时展示路径的长度（所有边权值之和）。\r\n     * *********************\r\n     * ✅ 可选功能：如果用户只输入一个单词，则程序计\r\n     * 算出该单词到图中其他任一单词的最短路径，并\r\n     * 逐项展示出来。\r\n     * *********************\r\n     * @param word1 单词1\r\n     * @param word2 单词2\r\n     * @return 最短路径的字符串\r\n     */\r\n    private static String calcShortestPath(String word1, String word2) throws IOException {\r\n        List<List<Object>> paths = graph.Dijkstra(word1);\r\n        if (paths == null) return \"\\\"\" + word1 + \"\\\" is not exist\";\r\n        if (!graph.getVertexes().contains(word2)) return \"\\\"\" + word2 + \"\\\" is not exist\";\r\n        List<Object> res = paths.get(graph.getVertex(word2));\r\n\r\n        // 突出显示路径\r\n        List<Edge> path = new ArrayList<>();\r\n        String[] nodes = ((String) res.get(0)).split(\"-->\");\r\n        String preword = null;\r\n        for (String node : nodes){\r\n            if (preword != null) path.add(new Edge(preword, node, graph.getEdge(preword, node)));\r\n            preword = node;\r\n        }\r\n        showDirectedGraph(graph, path, \"graph_path.svg\");\r\n        return (\"(\" + res.get(1) + \"): \" + res.get(0));\r\n    }\r\n\r\n    private static String calcShortestPath(String word1) {\r\n        List<List<Object>> paths = graph.Dijkstra(word1);\r\n        if (paths == null) return \"\\\"\" + word1 + \"\\\" is not exist\";\r\n        StringBuilder res = new StringBuilder();\r\n        for (List<Object> path : paths){\r\n            res.append(\"(\").append(path.get(1)).append(\"): \").append(path.get(0)).append(\"\\n\");\r\n        }\r\n        return res.toString();\r\n    }\r\n\r\n    /**\r\n     * 进入该功能时，程序随机的从图中选择一个节\r\n     * 点，以此为起点沿出边进行随机遍历，记录经\r\n     * 过的所有节点和边，直到出现第一条重复的边\r\n     * 为止，或者进入的某个节点不存在出边为止。\r\n     * 在遍历过程中，用户也可通过键入\'i\'键随时\r\n     * 停止遍历。\r\n     * *********************\r\n     * @return 随机路径的字符串\r\n     */\r\n    private static String randomWalk() throws IOException, InterruptedException, NativeHookException {\r\n        boolean[] visited = new boolean[graph.size()];\r\n        // 随机起点\r\n        Random random = new Random();\r\n        int randomIndex = random.nextInt(graph.size());\r\n        String v = graph.getVertex(randomIndex);\r\n\r\n        StringBuilder path = new StringBuilder(v);\r\n        List<Edge> paths = new ArrayList<>();\r\n        visited[randomIndex] = true;\r\n        List<String> neighbors;\r\n\r\n        try {\r\n            GlobalScreen.registerNativeHook();\r\n        } catch (NativeHookException ex) {\r\n            System.err.println(\"注册全局键盘监听器失败\");\r\n            System.exit(1);\r\n        }\r\n\r\n        isRunning=true;\r\n        GlobalScreen.addNativeKeyListener(new NativeKeyListener() {\r\n            public void nativeKeyPressed(NativeKeyEvent e) {\r\n                if (NativeKeyEvent.getKeyText(e.getKeyCode()).equalsIgnoreCase(\"i\")) {\r\n                    isRunning = false;\r\n                }\r\n            }\r\n\r\n            public void nativeKeyReleased(NativeKeyEvent e) { }\r\n\r\n            public void nativeKeyTyped(NativeKeyEvent e) { }\r\n        });\r\n\r\n        while ((neighbors = graph.getNeighbors(v)) != null) {\r\n            Thread.sleep(2000);\r\n            if (isRunning) {\r\n                // 随机选择邻居\r\n                randomIndex = random.nextInt(graph.size());\r\n                while (!neighbors.contains(graph.getVertex(randomIndex))) randomIndex = random.nextInt(graph.size());\r\n\r\n                path.append(\"-->\").append(graph.getVertex(randomIndex));\r\n                paths.add(new Edge(v, graph.getVertex(randomIndex), graph.getEdge(v, graph.getVertex(randomIndex))));\r\n\r\n                imageFrame.draw(graph, paths, \"random_walk.svg\");\r\n                System.out.println(path);\r\n\r\n                if (visited[randomIndex]) break;\r\n                else visited[randomIndex] = true;\r\n                v = graph.getVertex(randomIndex);\r\n            }\r\n            else {\r\n                System.out.println(\"User interrupt.\");\r\n                break;\r\n            }\r\n        }\r\n\r\n        GlobalScreen.unregisterNativeHook();\r\n        return path.toString();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * GUI窗口，用于展示有向图\r\n * 利用 Graphviz 生成图片并保存，读取图片展示在界面上\r\n */\r\nclass ImageFrame extends JFrame {\r\n\r\n    public void draw(Graph graph, List<Edge> path, String filename) throws IOException {\r\n        setTitle(\"Graph Display\");\r\n\r\n        // 移除所有组件\r\n        Container contentPane = getContentPane();\r\n        contentPane.removeAll();\r\n        contentPane.repaint();\r\n        contentPane.revalidate();\r\n\r\n        generateImage(graph, path, filename);\r\n\r\n        // 使用Batik创建SVG画布\r\n        JSVGCanvas canvas = new JSVGCanvas();\r\n        canvas.setURI(filename);\r\n\r\n        // 创建一个标签并设置画布\r\n        JScrollPane scrollPane = new JScrollPane(canvas);\r\n        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\r\n        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\r\n        add(scrollPane);\r\n\r\n        // 设置窗口大小\r\n        setSize(new Dimension(500, 500));\r\n\r\n//        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n        setVisible(true);\r\n    }\r\n\r\n    public void generateImage(Graph graph, List<Edge> path, String filename) throws IOException {\r\n        List<String> vertexes = graph.getVertexes();\r\n        List<Edge> edges = graph.getEdges();\r\n        Map<String, Node> nodes = vertexes.stream().collect(Collectors.toMap(vertex -> vertex, Factory::node, (a, b) -> b));\r\n        LinkSource[] linkSources = new LinkSource[edges.size()];\r\n        int index = 0;\r\n        for (Edge edge:edges){\r\n            linkSources[index++] = nodes.get(edge.from())\r\n                    .link(\r\n                            Link.to(nodes.get(edge.to()))\r\n                                    .with(guru.nidi.graphviz.attribute.Label.of(Integer.toString(edge.value())), path.contains(edge)? guru.nidi.graphviz.attribute.Color.RED: Color.BLACK)\r\n                    );\r\n        }\r\n        guru.nidi.graphviz.model.Graph g = graph(\"text\").directed()\r\n                .linkAttr().with(\"class\", \"link-class\")\r\n                .with(linkSources);\r\n        Graphviz.fromGraph(g).render(Format.SVG).toFile(new File(filename));\r\n    }\r\n}',2,'图最短路径算法',676,'java'),(10,'quick-sort','public void quickSort(int[] arr, int low, int hight){ \n...',1,'一个快排测试',100,'java'),(11,'quick-sort','public void quickSort(int[] arr, int low, int hight){ \n...',1,'一个快排测试',100,'java');
/*!40000 ALTER TABLE `algorithm` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `algorithm_tag`
--

DROP TABLE IF EXISTS `algorithm_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `algorithm_tag` (
  `algo_id` int unsigned NOT NULL COMMENT '算法id',
  `tag` varchar(30) NOT NULL COMMENT '算法标签'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COMMENT='算法库标签信息';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `algorithm_tag`
--

LOCK TABLES `algorithm_tag` WRITE;
/*!40000 ALTER TABLE `algorithm_tag` DISABLE KEYS */;
INSERT INTO `algorithm_tag` VALUES (1,'sort'),(1,'quick-sort'),(9,'graph'),(10,'sort'),(10,'quick-sort'),(11,'sort'),(9,'shortest-path');
/*!40000 ALTER TABLE `algorithm_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user` (
  `user_id` int unsigned NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `username` varchar(20) NOT NULL COMMENT '用户名',
  `password` varchar(30) NOT NULL COMMENT '密码',
  `admin` tinyint unsigned NOT NULL DEFAULT '0' COMMENT '是否为管理员 0为普通用户 1为管理员',
  `score` int unsigned NOT NULL DEFAULT '0' COMMENT '用户得分',
  `avatar` varchar(100) NOT NULL COMMENT '用户头像URL',
  `email` varchar(30) NOT NULL COMMENT '用户邮箱',
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb3 COMMENT='用户表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES (1,'admin','123456',1,10,'https://avatars.githubusercontent.com/u/171446778','123456@email.com'),(2,'Alice','111',0,20,'https://avatars.githubusercontent.com/u/3831173','alice@email.com'),(4,'Tom','123',0,0,'https://avatars.githubusercontent.com/u/171446778','TOM@email.com'),(9,'David','p@ssw0rd',0,0,'https://avatars.githubusercontent.com/u/171446778','123456@email.com');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2024-06-06 11:52:18
